import React, { createContext, useReducer, useContext, useRef, useEffect } from 'react';

var Star = /*#__PURE__*/function () {
  function Star(x, y, opacity, canvas) {
    this.x = x;
    this.y = y;
    this.opacity = opacity;
    this.canvas = canvas;
    this.length = Math.floor(Math.random() * 2) + 1;
    this.factor = 1;
    this.increment = Math.random() * 0.03;
  }

  var _proto = Star.prototype;

  _proto.draw = function draw() {
    var ctx = this.canvas.getContext("2d");

    if (this.opacity > 1) {
      this.factor = -1;
    } else if (this.opacity <= 0) {
      this.factor = 1;
    }

    this.opacity += this.increment * this.factor;

    if (ctx) {
      ctx.beginPath();
      ctx.fillRect(this.x, this.y, this.length, this.length);
      ctx.closePath();
      ctx.fillStyle = "rgba(255, 255, 255, 1)";
      ctx.fill();
      ctx.restore();
    }
  };

  return Star;
}();

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var ACTION;

(function (ACTION) {
  ACTION["INIT"] = "INIT";
  ACTION["FILL_STARS"] = "FILL_STARS";
  ACTION["RENDER_STARS"] = "RENDER_STARS";
  ACTION["SET_CANVAS_DIMENSIONS"] = "SET_CANVAS_DIMENSIONS";
  ACTION["ERROR"] = "ERROR";
})(ACTION || (ACTION = {}));

var initialContext = {
  fps: 50,
  numStars: 300,
  innerWidth: 0,
  innerHeight: 0,
  stars: []
};
var SpaceBackgroundStateContext = /*#__PURE__*/createContext(initialContext);
var SpaceBackgroundDispatchContext = /*#__PURE__*/createContext(function () {});

var spaceBackgroundReducer = function spaceBackgroundReducer(state, action) {
  switch (action.type) {
    case ACTION.FILL_STARS:
    case ACTION.SET_CANVAS_DIMENSIONS:
      return _extends({}, state, action.state);

    case ACTION.RENDER_STARS:
      return _extends({}, state);

    case ACTION.ERROR:
      return _extends({}, state);

    default:
      return state;
  }
};

function SpaceBackgroundProvider(_ref) {
  var children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  var _useReducer = useReducer(spaceBackgroundReducer, _extends({}, initialContext)),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  return React.createElement(SpaceBackgroundStateContext.Provider, Object.assign({
    value: state
  }, props), React.createElement(SpaceBackgroundDispatchContext.Provider, {
    value: dispatch
  }, children));
}
function useSpaceBackgroundState() {
  var context = useContext(SpaceBackgroundStateContext);

  if (!context) {
    throw new Error("useSpaceBackgroundState must be used after an SpaceBackgroundStateContext.Provider");
  }

  return context;
}
function useSpaceBackgroundDispatch() {
  var context = useContext(SpaceBackgroundDispatchContext);

  if (!context) {
    throw new Error("useSpaceBackgroundDispatch must be used after and SpaceBackgroundDispatchContext.Provider");
  }

  return context;
}
function useSpaceBackgroundContext() {
  return [useSpaceBackgroundState(), useSpaceBackgroundDispatch()];
}
function setCanvasDimensions(dispatch, _ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      canvas = _ref2.canvas;
  canvas.setAttribute("width", String(width));
  canvas.setAttribute("height", String(height));
  return dispatch({
    type: ACTION.SET_CANVAS_DIMENSIONS,
    state: {
      innerWidth: parseInt(String(width)),
      innerHeight: parseInt(String(height))
    }
  });
}
function fillStars(dispatch, _ref3) {
  var innerWidth = _ref3.innerWidth,
      innerHeight = _ref3.innerHeight,
      canvas = _ref3.canvas,
      numStars = _ref3.numStars;
  var stars = [];

  if (numStars) {
    for (var i = 0; i < numStars; i++) {
      var x = Math.round(Math.random() * (innerWidth != null ? innerWidth : 0));
      var y = Math.round(Math.random() * (innerHeight != null ? innerHeight : 0));
      var opacity = Math.random() * 0.5;

      if (canvas) {
        var star = new Star(x, y, opacity, canvas);
        stars.push(star);
      }
    }

    return dispatch({
      type: ACTION.FILL_STARS,
      state: {
        numStars: numStars,
        stars: stars
      }
    });
  }
}
function renderStar(dispatch, _ref4) {
  var _ref4$innerWidth = _ref4.innerWidth,
      innerWidth = _ref4$innerWidth === void 0 ? 0 : _ref4$innerWidth,
      _ref4$innerHeight = _ref4.innerHeight,
      innerHeight = _ref4$innerHeight === void 0 ? 0 : _ref4$innerHeight,
      canvas = _ref4.canvas,
      _ref4$stars = _ref4.stars,
      stars = _ref4$stars === void 0 ? [] : _ref4$stars;

  if (canvas) {
    var ctx = canvas.getContext("2d");
    ctx == null ? void 0 : ctx.clearRect(0, 0, innerWidth, innerHeight);
    stars.forEach(function (star) {
      star.draw();
    });
    return dispatch({
      type: ACTION.RENDER_STARS,
      state: {
        stars: stars
      }
    });
  }
}

var SpaceBackground = function SpaceBackground(_ref) {
  var _ref$width = _ref.width,
      width = _ref$width === void 0 ? 0 : _ref$width,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? 0 : _ref$height,
      props = _objectWithoutPropertiesLoose(_ref, ["width", "height"]);

  var _useSpaceBackgroundCo = useSpaceBackgroundContext(),
      state = _useSpaceBackgroundCo[0],
      dispatch = _useSpaceBackgroundCo[1];

  var stars = state.stars,
      numStars = state.numStars,
      innerWidth = state.innerWidth,
      innerHeight = state.innerHeight;
  var canvasRef = useRef(null);
  useEffect(function () {
    function initCanvas() {
      var canvas = canvasRef.current;

      if (canvas) {
        setCanvasDimensions(dispatch, {
          width: width,
          height: height,
          canvas: canvas
        });
      }
    }

    initCanvas();
  }, [width, height, dispatch, canvasRef]);
  useEffect(function () {
    function initStars() {
      var canvas = canvasRef.current;

      if (canvas) {
        fillStars(dispatch, {
          canvas: canvas,
          numStars: numStars,
          innerWidth: innerWidth,
          innerHeight: innerHeight
        });
      }
    }

    initStars();
  }, [numStars, innerWidth, innerHeight, dispatch, canvasRef]);
  useEffect(function () {
    function initRenderStars() {
      var canvas = canvasRef.current;

      if (canvas) {
        renderStar(dispatch, {
          canvas: canvas,
          stars: stars,
          innerWidth: innerWidth,
          innerHeight: innerHeight
        });
      }
    }

    initRenderStars();
  }, [stars, innerWidth, innerHeight, dispatch, canvasRef]);
  return React.createElement("canvas", Object.assign({
    ref: canvasRef
  }, props));
};

export { SpaceBackground, SpaceBackgroundDispatchContext, SpaceBackgroundProvider, SpaceBackgroundStateContext, Star, fillStars, initialContext, renderStar, setCanvasDimensions, useSpaceBackgroundContext, useSpaceBackgroundDispatch, useSpaceBackgroundState };
//# sourceMappingURL=react-space-background.esm.js.map
